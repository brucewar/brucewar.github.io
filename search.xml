<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[跑步带给了我什么]]></title>
      <url>http://brucewar.me/2016/11/29/%E8%B7%91%E6%AD%A5%E5%B8%A6%E7%BB%99%E4%BA%86%E6%88%91%E4%BB%80%E4%B9%88/</url>
      <content type="text"><![CDATA[从年初2月份到现在，我已经坚持跑步大半年了，虽然频率不高（平均一周跑三次，每次5公里），姑且算是坚持下来了。还记得刚开始是因为前同事（蕾爷和阿汤）的怂恿，让我一起报名参加上海松江的首届半程马拉松比赛，不过因为大家都是第一次跑，所以没敢报半程，最终报的是12km健康跑。也是当时脑子一热，让我将跑步坚持了这么久，并且参加了今年南京的马拉松，不过跑的是5公里。 题外话：没错，你看到就是蒋劲夫，他也是一个坚持运动的人，最近看的一档节目《真正的男子汉》也对他有所关注。 知乎里常常看到一些关于跑步的话题，如“坚持跑步到底有什么改变？”。所以我有时也会想问问自己，坚持跑步给我带来了什么改变，也就有了这篇文章。先说说生理上变化吧！我觉得最大的改变就是整个人的精神面貌不一样了，作为程序员的一员，每天坐着的时间比站着的时间多得多，而且整天面对着电脑，一天下来都是油光满面，提不起精神。自从跑步后，周围的同事都说我“容光焕发”。当然，还有一些附带的变化就是肚子上的赘肉也少了（额，还是有点的），睡眠质量提高，也很少生病了。 但是，这些生理上的变化微乎其微，坚持跑步贵在坚持，它真正带给我的是生活和工作上的变化。因为跑步，我认识了许多同样把跑步真正坚持下来的人，有时大家也会约着一起在咕咚APP上画圈。 跑步也让我的生活更加规律，早睡早起已然成为我的习惯。每当早上赖床时，我会想到，“跑步时也有过真的坚持不下去的时候，我会告诉自己，你还可以再跑1公里”，我还会想到，坚持跑步这么难的习惯，我都坚持下来了，还有什么习惯不能坚持。坚持跑步给我带来了自制力，也给了我认真对待生活的态度。我很享受跑步过程，一步一个脚印，不断给自己设立新的目标。 违背了自己定下的原则，哪怕只有一次，以后就将违背更多的原则。 —— 村上春树 《当我谈跑步时我谈些什么》 此外，跑步也让我变的更自信了。面对工作和生活中遇到的一些问题，我能从容地面对并解决它们。也正是因为跑步，睡眠质量提高了，所以白天工作的精神状态很好，能更专注的工作和学习。 现在，我又有了两件坚持做的事，我觉得这也是跑步带给我，一是坚持看书，第二件也就是坚持写博客。跑步给我带来的是身体健康的延续，而看书写博客则给我带来的是精神上积累和沉淀。我相信，我会像坚持跑步一样，把这两件事坚持下去，同样也会继续将跑步坚持下去。 一生做好一件事，一天看一个小时书，这就够了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3.js（Draggable and Scalable Tree）]]></title>
      <url>http://brucewar.me/2016/10/27/D3.js-Draggable%20and%20Scalable%20Tree/</url>
      <content type="text"><![CDATA[因为最近手上有个小的需求，设计一个可缩放和可拖拽的树形结构，我便去研读了D3官网给的一个树形的例子。 布局（Layout）原本我以为理解了基本的选择器、元素操作、Enter、Exit就能去看实例的代码了，后来发现我错了，所以这里需要理解一下D3中布局（Layout）的概念。布局是D3中一个十分重要的概念，从布局衍生出很多图表。例如：饼状图（pie）、力导向图（force），树状图（tree）等等，基本实现了很多开源的可视化工具提供的图表。但是它又和很多可视化工具（如Echarts）有很大的不同。 相对于其它工具来说，D3较底层一点，所以初学者可能会觉得有点困难，但是一旦理解了D3布局的思想，使用起来，会比其它工具更加得心应手。首先，我阐释下D3和大部分可视化工具数据到图表的流程： 大部分可视化工具：数据 =&gt; 封装好的绘图函数 =&gt; 图表 D3：数据 =&gt; Layout =&gt; 绘图所需的数据 =&gt; 绘制图形 =&gt; 图表 可以看出，D3需要自己去绘制图形，但是可以通过布局函数获得绘图所需要的数据，坏处是对初学者是一个很大的考验，好处是它能帮助我们制作出更加精密的图形。 树状图回归正题，如何设计一个树形结构，我将从D3官网提供的示例代码分析。 页面代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;tree&lt;/title&gt; &lt;style&gt; body&#123; margin: 0; &#125; svg&#123; background-color: #eee; &#125; .node circle &#123; cursor: pointer; fill: #fff; stroke: steelblue; stroke-width: 1.5px; &#125; .node text &#123; font-size: 11px; &#125; path.link &#123; fill: none; stroke: #ccc; stroke-width: 1.5px; &#125; g.detail rect&#123; fill: #000; fill-opacity: .6; rx: 5; ry: 5; &#125; g.detail text&#123; fill: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="treeContainer"&gt;&lt;/div&gt; &lt;script src="./dist/tree.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 因为D3示例代码是同步的形式读出整个树形数据结构，我对其进行了改造，模拟异步数据（async_city.json）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#123; "root": &#123; "name": "中国" &#125;, "中国": &#123; "name": "中国", "children": [ &#123;"name": "浙江"&#125;, &#123;"name": "广西"&#125;, &#123;"name": "黑龙江"&#125;, &#123;"name": "新疆"&#125; ] &#125;, "浙江": &#123; "name": "浙江", "children": [ &#123;"name": "杭州"&#125;, &#123;"name": "宁波"&#125;, &#123;"name":"温州" &#125;, &#123;"name":"绍兴" &#125; ] &#125;, "广西": &#123; "name": "广西", "children": [ &#123;"name": "桂林"&#125;, &#123;"name": "南宁"&#125;, &#123;"name": "柳州"&#125;, &#123;"name": "防城港"&#125; ] &#125;, "桂林": &#123; "name": "桂林", "children": [ &#123;"name":"秀峰区"&#125;, &#123;"name":"叠彩区"&#125;, &#123;"name":"象山区"&#125;, &#123;"name":"七星区"&#125; ] &#125;, "黑龙江": &#123; "name":"黑龙江", "children": [ &#123;"name":"哈尔滨"&#125;, &#123;"name":"齐齐哈尔"&#125;, &#123;"name":"牡丹江"&#125;, &#123;"name":"大庆"&#125; ] &#125;, "新疆" : &#123; "name":"新疆" , "children": [ &#123;"name":"乌鲁木齐"&#125;, &#123;"name":"克拉玛依"&#125;, &#123;"name":"吐鲁番"&#125;, &#123;"name":"哈密"&#125; ] &#125;&#125; 画布123456789101112131415161718192021222324var margin = &#123; top: 20, left: 50, right: 50, bottom: 20&#125;;var width = $(document).width(), height = $(document).height(), i = 0, limit = 2, root; // draggable and scalable var zoomListener = d3.behavior.zoom().scaleExtent([0.1, 3]).on('zoom', zoom); function zoom()&#123; d3.select('svg').select('g').attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')'); &#125; var svg = d3.select("#treeContainer").append("svg") .attr("width", width - margin.left - margin.right) .attr("height", height - margin.top - margin.bottom) .call(zoomListener) .append("g") .attr("transform", "translate(" + margin.left + "," + margin.top + ")"); 获取异步数据1234567// 异步获取数据function getData(sd, cb)&#123; d3.json('data/async_city.json', function(err, json)&#123; // 通过callback返回部分数据 cb &amp;&amp; cb(json[sd.name]); &#125;);&#125; 构造树123456789// 获取树的rootgetData(&#123;name: 'root'&#125;, function(json)&#123; root = json; root.x0 = height / 2; root.y0 = width / 2; // 初始化树根 update(root);&#125;); 从上面的代码可以看出构造树的核心代码就是这个update函数，下面以注释的形式深入理解树形的构造。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185// 新建一个树的布局var tree = d3.layout.tree() .size([height - margin.top - margin.bottom, width - margin.left - margin.right]);// 因为默认的树布局是自上而下的，这里构建一个自左向右的树，故需要一个转换x和y坐标的函数var diagonal = d3.svg.diagonal() .projection(function(d) &#123; return [d.y, d.x]; &#125;);function update(source) &#123; var duration = d3.event &amp;&amp; d3.event.altKey ? 5000 : 500; /** * 这里实际上是通过tree的nodes函数获得树形结构的每个节点的数据，包括位置信息和深度 * 返回的数据结构如下： * [&#123;depth: 0, name: "中国", children: [], x: 380, y: 0&#125;] */ var nodes = tree.nodes(root).reverse(); // 为了让当前节点居中，故更具当前节点的depth来计算各节点的y坐标（即横向位置） var srcDepth = source.depth; nodes.forEach(function(d)&#123; d.y = height / 2 + 180 * (d.depth - srcDepth); &#125;); // Update the nodes… var node = svg.selectAll("g.node") .data(nodes, function(d) &#123; return d.id || (d.id = ++i); &#125;); // Enter any new nodes at the parent's previous position. var nodeEnter = node.enter().append("g") .attr("class", "node") .attr("transform", function(d) &#123; return "translate(" + source.y0 + "," + source.x0 + ")"; &#125;) .on("click", click) .on('mouseover', function(d)&#123; if(d.name == 'more') return; // 鼠标hover某个节点时，显示一个详细信息的弹层 var detail = d3.select(this).append('g') .attr('class', 'detail') .attr('dx', d3.event.x) .attr('dy', d3.event.y + 10); detail.append('rect') .attr('width', 100) .attr('height', 100); detail.append('text') .attr('dx', '.35em') .attr('dy', '2em') .attr('text-anchor', 'start') .text(function(d)&#123; return 'name: ' + d.name; &#125;); &#125;) .on('mousemove', function(d)&#123; var detail = d3.select(this).select('.detail'); detail.attr('x', d3.event.x) .attr('y', d3.event.y); &#125;) .on('mouseout', function(d)&#123; if(d.name == 'more') return; d3.select(this).select('.detail').remove(); &#125;); nodeEnter.append("circle") .attr("r", 1e-6) .style("fill", function(d)&#123; return !d.isExpand ? "lightsteelblue" : "#fff"; &#125;); nodeEnter.append("text") .attr("x", -10) .attr("dy", ".35em") .attr("text-anchor", "end") .text(function(d) &#123; return d.name; &#125;) .style("fill-opacity", 1e-6); // Transition nodes to their new position. var nodeUpdate = node.transition() .duration(duration) .attr("transform", function(d) &#123; return "translate(" + d.y + "," + d.x + ")"; &#125;); nodeUpdate.select("circle") .attr("r", 10) .style("fill", function(d)&#123; return !d.isExpand ? "lightsteelblue" : "#fff"; &#125;); nodeUpdate.select("text") .style("fill-opacity", 1); // Transition exiting nodes to the parent's new position. var nodeExit = node.exit().transition() .duration(duration) .attr("transform", function(d) &#123; if(d.name == 'more') this.remove(); return "translate(" + source.y + "," + source.x + ")"; &#125;) .remove(); nodeExit.select("circle") .attr("r", 1e-6); nodeExit.select("text") .style("fill-opacity", 1e-6); /** Update the links... * tree.links方法获取连线节点之间的映射，返回的数据结构如下： * [&#123;source: &#123;&#125;, target: &#123;&#125;&#125;] */ var link = svg.selectAll("path.link") .data(tree.links(nodes), function(d) &#123; return d.target.id; &#125;); // Enter any new links at the parent's previous position. link.enter().insert("path", "g") .attr("class", "link") .attr("d", function(d) &#123; var o = &#123;x: source.x0, y: source.y0&#125;; return diagonal(&#123;source: o, target: o&#125;); &#125;) .transition() .duration(duration) .attr("d", diagonal); // Transition links to their new position. link.transition() .duration(duration) .attr("d", diagonal); // Transition exiting nodes to the parent's new position. link.exit().transition() .duration(duration) .attr("d", function(d) &#123; if(d.target.name == 'more') this.remove(); var o = &#123;x: source.x, y: source.y&#125;; return diagonal(&#123;source: o, target: o&#125;); &#125;) .remove(); // Stash the old positions for transition. // 记录当前节点所在的位置，为node update提供位移动画 nodes.forEach(function(d) &#123; d.x0 = d.x; d.y0 = d.y; &#125;);&#125;function collapse(d)&#123; delete d._children; delete d.isExpand; delete d.children;&#125;function expand(d)&#123; getData(&#123;name: d.name&#125;, function(json)&#123; if(json &amp;&amp; json.children)&#123; // 获取到此节点有子节点 d._children = json.children; d.children = d._children.slice(0, limit); if(d._children.length &gt; d.children.length)&#123; d.children.push(&#123;'name': 'more'&#125;); &#125; &#125; d.isExpand = true; update(d); &#125;);&#125;// 异步获取数据function getData(sd, cb)&#123; d3.json('data/async_city.json', function(err, json)&#123; cb &amp;&amp; cb(json[sd.name]); &#125;);&#125;function click(d)&#123; if(d.name == 'more')&#123; // 点击更多 d.parent.children = d.parent._children.slice(0, (d.parent.children.length - 1) + limit); if(d.parent._children.length &gt; d.parent.children.length)&#123; d.parent.children.push(&#123;'name': 'more'&#125;); &#125; update(d.parent); &#125;else if(d.isExpand &amp;&amp; d.children)&#123; // 点击展开的节点 collapse(d); update(d); &#125;else&#123; // 点击未展开的点 expand(d); &#125;&#125; 可以从https://github.com/brucewar/practice-in-D3获取示例代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3.js（完整的柱状图）]]></title>
      <url>http://brucewar.me/2016/10/25/D3.js-%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
      <content type="text"><![CDATA[首先，我们先看一下最终的柱状图效果展示。如下图所示，一个完整的柱状图需要包含三个部分：矩形、文字、坐标轴。 添加SVG画布12345678910111213141516// 画布大小var width = 400,height = 400;// 画布四个方向上的留白var margin = &#123; top: 20, right: 30, bottom: 20, left: 30&#125;;var chart = d3.select('.chart').attr('width', width).attr('height', height).append('g'); 定义比例尺12345// define x,y point rulevar x = d3.scale.ordinal().rangeRoundBands([0, width - margin.left - margin.right]);var y = d3.scale.linear().range([height - margin.top - margin.bottom, 0]); 添加矩形及文字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 矩形之间的空白var barPadding = 4;/*** 这里用到了d3异步读取数据的接口csv* chart.csv的文件内容如下：* name,value* Locke,4* Reyes,8* Ford,15* Jarrah,16* Shephard,23* Kwon,42*/d3.csv('data/chart.csv', type, function(err, data)&#123; x.domain(data.map(function(d)&#123; return d.name; &#125;)); y.domain([0, d3.max(data, function(d)&#123; return d.value; &#125;)]); // append rect chart.selectAll('.bar') .data(data) .enter().append('rect') .attr('class', 'bar') .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')') .attr('x', function(d)&#123; return x(d.name) + barPadding / 2; &#125;) .attr('y', function(d)&#123; return y(d.value); &#125;) .attr('height', function(d)&#123; return height - margin.top - margin.bottom - y(d.value); &#125;) .attr('width', x.rangeBand() - barPadding); // append text chart.selectAll('.text') .data(data) .enter() .append('text') .attr('class', 'text') .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')') .attr('x', function(d)&#123; return x(d.name) + barPadding / 2; &#125;).attr('y', function(d)&#123; return y(d.value); &#125;).attr('dx', function()&#123; return (x.rangeBand() - barPadding) / 2; &#125;).attr('dy', 20) .text(function(d)&#123; return d.value; &#125;);&#125;);function type(d)&#123; d.value = +d.value; return d;&#125; 定义并添加坐标轴1234567891011121314151617181920212223242526// define axisvar xAxis = d3.svg.axis().scale(x).orient('bottom');var yAxis = d3.svg.axis().scale(y).orient('left').ticks(10); //显示的刻度值个数// append x axischart.append('g').attr('class', 'x axis').attr('transform', 'translate(' + margin.left + ', ' + (height - margin.bottom) + ')').call(xAxis);// append y axischart.append('g').attr('class', 'y axis').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')').call(yAxis).append('text').attr('transform', 'rotate(-90)').attr('y', 6).attr('dy', '.71em').style('text-anchor', 'end').text('value'); 可以从https://github.com/brucewar/practice-in-D3获取示例代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D3.js（入门篇）]]></title>
      <url>http://brucewar.me/2016/10/24/D3.js-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      <content type="text"><![CDATA[简介D3.js（后面简称D3，官方首页https://d3js.org/）是基于JavaScript开发的一套用于数据可视化工具，项目开源在GitHub，项目排名靠前。它提供了很多API，如DOM（Document Object Model）的一些操作，绘制图形等。截止本文发表时间，D3已更新到v4，v4在v3的基础上，有了很大的改变（因为v3只支持通过svg和dom构图，所以v4在v3的基础上增加了对Canvas的支持以及API的修改）,本文使用的版本为v3的API。 Hello World12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;D3.js Hello World&lt;/title&gt; &lt;script src="https://d3js.org/d3.v3.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;first text&lt;/p&gt; &lt;p&gt;second text&lt;/p&gt; &lt;p&gt;third text&lt;/p&gt; &lt;script&gt; var p = d3.select('body').selectAll('p') .attr('color', 'red') .attr('font-size', '72px') .text('brucewar'); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面代码展示了基本的DOM操作，有过jQuery开发经历的人会发现其语法和jQuery很相似，主要是以下两点： 支持元素选择器 链式语法结构 插入元素1234// 末尾插入p元素d3.select('body').append('p').text('append new prograph');// 在第一个p元素之前插入pd3.select('p').insert('p').text('insert new prograph'); 删除元素1d3.select('p').remove(); 数据绑定在D3中，选择器通常和数据绑定一起使用，这里的数据绑定的意思是将DOM元素与数据进行绑定，当需要依靠数据操作元素会非常方便。12345var arr = ['a', 'b', 'c'];p.data(arr).text(function(d, i)&#123; // d: 数据 i: 元素索引 return d;&#125;); 绘制简单的横向柱状图 添加svg画布 1234567var width = 300;var height = 300;var svg = d3.select('body').append('svg').attr('width'. width).attr('height', height); 绘制矩形 12345678910111213141516var data = [250, 210, 170, 130, 90]; // 表示矩形的宽度var rectHeight = 25;svg.selectAll('rect').data(data).enter() // 当元素个数不足数据个数时，自动补全.append('rect').attr('x', 20).attr('y', function(d, i)&#123; return i * rectHeight;&#125;).attr('width', function(d)&#123; return d;&#125;).attr('height', rectHeight - 2).attr('fill', 'steelblue'); 从上面的代码可以看出当data中的数据大于画布的宽度时，绘制的矩形会超出画布，所以需要引入比例尺（Scale）的概念。比例尺的概念类似数学中的一元二次函数，有x和y两个未知数，当x的值确定时，y的值也就确定了，x范围被称为定义域，y的范围为值域，对应于D3比例尺中的domain和range。D3为我们提供了很多比例尺，这里主要讲这里柱状图所要使用的线性比例尺。 123456var min = d3.min(data);var max = d3.max(data);var linear = d3.scale.linear().domain([min, max]).range([0, 300]); 绘制坐标轴 1234567891011//数据var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];//定义比例尺var linear = d3.scale.linear() .domain([0, d3.max(dataset)]) .range([0, 250]);var axisX = d3.svg.axis() .scale(linear) //指定比例尺 .orient("bottom") //指定刻度的方向 .ticks(7); //指定刻度的数量 定义了坐标轴之后，只要在svg中添加一个分组元素，再将坐标轴的其他元素添加到分组即可。 1234svg.append('g').attr('class', 'axis').attr('transform', 'translate(20, 130)').call(axisX); 1234567891011/** 修改坐标轴样式 */.axis path,.axis line&#123; fill: none; stroke: black; shape-rendering: crispEdges;&#125;.axis text&#123; font-family: sans-serif; font-size: 11px;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[答利器上的六个问题]]></title>
      <url>http://brucewar.me/2016/09/29/%E7%AD%94%E5%88%A9%E5%99%A8%E4%B8%8A%E7%9A%84%E5%85%AD%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
      <content type="text"><![CDATA[介绍一下你自己和所做的工作我叫王金龙，是一名初级（按照工作年限来说的话）Web前端开发，但是以开发经历来说，我至少应该算一名合格的前端攻城狮。目前在途牛旅游网工作（已经寻找到新的追求）。读书的时候，接触的东西比较少，心里所想唯有学习，所以也就没培养任何一样兴趣，偶尔会和同学一起踢踢球；工作的时候，才逐渐培养了一些兴趣爱好，如跳舞、唱歌等，跳舞是今年才培养起来的一个兴趣，但是因为工作的关系，基本没什么时间练舞，所以跳的非常非常一般。15年研究生毕业后，工作也有一年半了，而且公司是业务驱动开发，所以代码也写了不少，可是自身能力的提升却没看出来。 你都在使用哪些硬件 这款机械键盘是工作没多久之后买的。话说，当时看到同组的一位老程序员（简称斌哥，后来他们组从我们部门分出去啦）用的机械键盘，黑色键帽配上彩虹键帽，觉得很好看，所以一时冲动想买一把机械键盘。 做什么事都要过一下脑子 上面这句话，印象很深刻，因为我对机械键盘的知识一片空白，所以必须通过各方面的了解，首先从百度百科词条机械键盘学习了基本的知识，然后去问答网站（知乎）关注了话题机械键盘，发现此话题下，有很多问题是“程序员男朋友生日，想送机械键盘，有推荐的吗？”。额！！！被各种虐，心想为啥没有妹子送我。不过，还是有很多人推荐了不错的机械键盘。个人感觉很喜欢Filco圣手二代，但是迫于经济能力有限，最终还是买了一把国产的红轴，用起来真的很舒服（PS：好多同事试玩后都觉得不错）。 舞蹈配上音乐之后，才有了灵魂 如果一个舞者在没有背景乐的环境下舞动自己的身体，非专业观者可能会觉得看不懂，专业的人也只能从专业技巧上加以评价。有了音乐后，舞者会随着音乐的轻重缓急表达自己的情绪，这才有了舞魂。程序员写代码时的手指就如同这舞者，在键盘这个舞台上表演，配合音乐的节奏，程序便有了它的灵魂（PS：我写程序时听的歌单dance）。AKG的这个经典款的耳机是昊哥推荐的，性价比非常高（非广告）。 显示器没什么可以说的，做为Web前端开发，两个显示器是必备的，一个放IDE，一个放浏览器，对于开发效率有非常大的提升。 软件呢作为Linux的拥护者，必须向大家推荐Vim编辑器，我觉得它能让你脱离不必要的鼠标操作，大大提高工作效率，很惭愧，Vim新手阶段，用的不是很熟，只了解一些简单的编辑命令。顺带安利一款Chrome插件Vimium（用Vim命令操作浏览器环境）。 你最理想的工作环境是什么大桌子（圆弧型），两台显示器，一台笔记本，网络一定要好（自带翻墙，Youtube 1080P不卡顿），绿植围绕，周围坐着谦虚耐心的牛人，大家一起干着一件有意义（改变世界，哈哈，这个太大）的事。 你平时获得工作灵感的方式有哪些逛各种网站，知乎，简书等；玩各种流行的APP，微信，Instagram等，任何一个好的产品，自有它的独特的一面，我觉得作为前端开发，也需要有一些设计的想法，我开发过的项目中都曾借鉴过这些应用。 推荐一件生活中的利器给大家VPN，强烈推荐我用的这款，但是这里不方便贴链接，有需要的私信我。]]></content>
    </entry>

    
  
  
</search>
